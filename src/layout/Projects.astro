---
//Styles
import resetStyles from "@styles/site.css";

// Components
import SEO from '@components/SEO.astro';
import ProjectNav from "@components/ProjectNav.astro";
import SmoothScroll from "@components/SmoothScroll.astro";

//Assets
import logo from "@images/logo-white.png";

export interface Props {
	pageTitle: string,
	pageUrl: string,
	pageImage: string,
	pageDescription?: string,
  	slides: {id: string}[]
}

const {
    pageTitle,
    slides
} = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>{pageTitle}</title>
		<meta name="viewport" content="width=device-width,initial-scale=1.0">

		<SEO { ...Astro.props }></SEO>

		<style is:inline set:html={resetStyles}></style>
		<link rel="icon" type="image/x-icon" href="favicon.ico">
	</head>

	<body>
        <ProjectNav slides={slides}/>
		<section class="slides">
			{
				slides.map(({id, component: Component}) => (
					<Component id={id}/>
				))
			}
		</section>
		<img src={logo} alt="Logo" class="logo projects"/>
    </body>
    <style>
        body{
            background-color: black;
			position: relative;
        }

		.slides{
			display: flex;
			gap: 1ch;
			overflow-x: auto;
			scroll-snap-type: x mandatory;
  			overscroll-behavior-x: contain;
			touch-action: pan-x;
			inline-size: 100%;
			block-size: 100%;
			height: 100vh;
			width: 100vw;
			 scrollbar-width: none;
    		-ms-overflow-style: none;
		}

		.slides::-webkit-scrollbar {
			width: 0;
			height: 0;
		}

		.logo{
			position: absolute;
			bottom: 16px;
			left: 50%;
			transform: translateX(-50%);
			display: none;
		}

		.logo.is-hidden{
			display: none;
		}

		@media (max-width: 600px){
			.logo{
				display: block;
			}
		}
    </style>
	<SmoothScroll/>
	<script>
		import { getSlidesObject, getActiveSlide } from "../utils/projectSlideUtils"
		import debounce from "../utils/debounce"
    	import throttle from "../utils/throttle"

		//Set DOM elements
		const slidesWrapper = document.querySelector('section.slides');
		const logoElement = document.querySelector('.projects.logo');
		const slides = [...document.querySelectorAll(".slides__slide")];
		const navbar = document.querySelector('.navbar');

		const DURATION_PER_SLIDE = 0.5

		//Generate object that maps slide ids to their index and dom element
		const slidesObject = getSlidesObject(".slides__slide")

		//Setup base state
		let state = {
			isScrolling: false,
			currentElement: slides[0].dataset.id
		};

		const setupBasePage = () => {
			//Get active slide from url
			const activeSlide = getActiveSlide({
				query: ".slides__slide",
				elementsObject: slidesObject
			})

			//If no active slide redirect user to first slide
			if(!activeSlide){
				window.location.hash = slides[0].id;
			}else{
				//Hide logo element on last page
				if(activeSlide === slides[slides.length - 1].dataset.id){
					logoElement.classList.add("is-hidden")
				}else{
					logoElement.classList.remove("is-hidden")
				}

				//If active slide is not first slide then scroll active slide into view
				if(activeSlide !== state.currentElement){
					slidesObject[activeSlide].element.scrollIntoView();
				}
			}
		}

		const setupObserver = () => {
			//Function to trigger on intersection change
			const handleIntersection = (entries) => {
				entries.forEach(entry => {
					if(entry.isIntersecting){
						//If the smooth scroll is currently active then don't change the hash
						if(state.isScrolling) return

						//Else change the hash and the current element because the scroll was triggered by the user's mouse events
						const id = entry.target.dataset.id;
						state.currentElement = id;
						window.location.hash = id;
					}
				})
			}

			//Create intersection observer
			const slideObserver = new IntersectionObserver(handleIntersection, {
				rootMargin: "0px",
				threshold: 0.9
			});

			//Observe all slides
			slides.forEach(element => {
				slideObserver.observe(element)
			});
		}

		const handleHashChange = () => {
			//Get current active slide
            const activeSlide = getActiveSlide({
				query: ".slides__slide",
				elementsObject: slidesObject
			})

			//If invalid slide redirect to first slide
			if(!activeSlide){
				window.location.hash = slides[0].dataset.id;
				return
			}

			//Hide logo element on last page
			if(activeSlide === slides[slides.length - 1].dataset.id){
				logoElement.classList.add("is-hidden")
			}else{
				logoElement.classList.remove("is-hidden")
			}

            const activeSlideEl = slidesObject[activeSlide].element;

			//On change slide. Reset contrast based on scroll position
			if(activeSlideEl.scrollTop > activeSlideEl.offsetHeight){
				navbar.classList.add('has-contrast')
			}else{
				navbar.classList.remove('has-contrast')
			}

			//Get slide width and active slide position
			const slideWidth = window.innerWidth;
			const activeSlideOffset = activeSlideEl.offsetLeft;

			/*
				The percentage here is used as such
				If percentage is <= 0.1 then the hash change was triggered by the intersection observer
				and therefore the user already used a normal scroll event and the scroll snap will align the page correctly

				If percentage > 0.1 then the hash change was triggered by clicking on the slides in the navbar
				and therefore we should scroll to the correct slide using the smooth scroll algorithm

			*/
			const percentage = Math.abs(activeSlideOffset - slidesWrapper.scrollLeft)/slideWidth

			if(percentage > 0.1){
				//Update scrolling
				state.isScrolling = true;

				//Calculate the number of slides to scroll by and then scale up duration of scroll animation by that
                const distanceToScroll = Math.abs(slidesWrapper.scrollLeft - activeSlideEl.offsetLeft);
                const numberOfSlides = distanceToScroll / window.innerWidth

                const duration = numberOfSlides * DURATION_PER_SLIDE


				smoothScroll({
					element: slidesWrapper,
					position: {
						x: activeSlideEl.offsetLeft,
						y: 0
					},
					duration,
					callback: () => {
						state.isScrolling = false
						state.currentElement = activeSlide
					},
					handleStopScroll: () => {
						/*
							When the user stops the scroll the URL sometimes does not match the active slide. 
							You can increase DURATION_PER_SLIDE to test properly. 
							Toggle to a far away slide using the nav then interrupt the scroll. 

							Because of this issue I'm checking the element positions against the wrapper scroll to verify which of the elements is active
							If the active element does not match the hash in the url then update the hash in the url
						*/
						const activeElement = slides.find(slide => {
							return Math.abs(slide.offsetLeft - slidesWrapper.scrollLeft) < 50
						});

						if(activeElement.dataset.id !== window.location.hash.slice(1)){
							window.location.hash = activeElement.dataset.id
						}
					},
					id: "slides",
					easing: "easeOutQuad"
				})
			}
        }

        window.addEventListener("hashchange", handleHashChange)

		const moveLeft = (currentIndex) => {
			if(currentIndex <= 0) return
			state.isScrolling = true;

			const previousElement = slides[currentIndex - 1].dataset.id;
			state.currentElement = previousElement
			window.location.hash = previousElement
		}

		const moveRight = (currentIndex) => {
			state.isScrolling = true;

			if(currentIndex >= slides.length - 1) return

			const nextElement = slides[currentIndex + 1].dataset.id;
			state.currentElement = nextElement
			window.location.hash = nextElement
		}
		
		const handleClickWrapper = ({clientX, path}) => {
			//This is to allow disabling toggle if an element has the attribute data-ignore-click
			const hasIgnore = path.find(el => "ignoreClick" in (el.dataset || {}))

			if(hasIgnore) return

			const middlePoint = slidesWrapper.offsetWidth / 2;
			const currentIndex = slidesObject[window.location.hash.slice(1)].index;

			//If mobile move left if click right else move right
			if(window.innerWidth <= 600){
				if(clientX < middlePoint){
					moveLeft(currentIndex)
				}else{
					moveRight(currentIndex)
				}
			}else{
				//If desktop scroll left if within 0 - 200 and scroll right if within width to width - 200
				if(clientX < 200){
					moveLeft(currentIndex)
				}

				if(clientX > slidesWrapper.offsetWidth - 200){
					moveRight(currentIndex)
				}
			}
		}

		slidesWrapper.addEventListener("click", debounce(handleClickWrapper, DURATION_PER_SLIDE * 1000))
		setupBasePage()
		setupObserver()

		const handleScrollEvent = (slide) => {
			const activeSlide = getActiveSlide({
				query: ".slides__slide",
				elementsObject: slidesObject
			})

			//If the slide is not active then no need to check it's scroll parameters
			if(activeSlide !== slide.dataset.id) return

        	if(slide.scrollTop > slide.offsetHeight){
				navbar.classList.add('has-contrast')
			}else{
				navbar.classList.remove('has-contrast')
			}
    	}

		slides.forEach(slide => {
			if(slide.dataset.addContrast){
				slide.addEventListener('scroll', throttle(() => handleScrollEvent(slide), 100))
			}
		})
		
	</script>
</html>