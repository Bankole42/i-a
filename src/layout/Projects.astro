---
//Styles
import resetStyles from "@styles/site.css";

// Components
import SEO from '@components/SEO.astro';
import ProjectNav from "@components/ProjectNav.astro";
import SmoothScroll from "@components/SmoothScroll.astro";
import SlideUtils from "@components/SlideUtils.astro";

//Assets
import logo from "@images/logo-white.png";

export interface Props {
	pageTitle: string,
	pageUrl: string,
	pageImage: string,
	pageDescription?: string,
  	slides: {id: string}[]
}

const {
    pageTitle,
    slides
} = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>{pageTitle}</title>
		<meta name="viewport" content="width=device-width,initial-scale=1.0">

		<SEO { ...Astro.props }></SEO>

		<style is:inline set:html={resetStyles}></style>
		<link rel="icon" type="image/x-icon" href="favicon.ico">
		<SlideUtils/>
	</head>

	<body>
        <ProjectNav slides={slides}/>
		<section class="slides">
			{
				slides.map(({id, component: Component}) => (
					<article class="slides__slide" data-id={id}>
						<Component/>
					</article>
				))
			}
		</section>
		<img src={logo} alt="Logo" class="logo"/>
    </body>
    <style>
        body{
            background-color: black;
			position: relative;
        }

		.slides{
			display: flex;
			gap: 1ch;
			overflow-x: auto;
			scroll-snap-type: x mandatory;
  			overscroll-behavior-x: contain;
			touch-action: pan-x;
			inline-size: 100%;
			block-size: 100%;
			height: 100vh;
			width: 100vw;
			 scrollbar-width: none;
    		-ms-overflow-style: none;
		}

		.slides::-webkit-scrollbar {
			width: 0;
			height: 0;
		}

		.slides__slide{
			scroll-snap-align: start;
			scroll-snap-stop: always;
			overflow-y: auto;
			width: 100vw;
			max-block-size: 100%;
			flex-shrink: 0;
			background-color: blue;
		}

		.logo{
			position: absolute;
			bottom: 16px;
			left: 50%;
			transform: translateX(-50%);
			display: none;
		}

		@media (max-width: 600px){
			.logo{
				display: block;
			}
		}
    </style>
	<SmoothScroll/>
	<script is:inline>
		//Set DOM elements
		const slidesWrapper = document.querySelector('section.slides');
		const slides = [...document.querySelectorAll(".slides__slide")];

		//Generate object that maps slide ids to their index and dom element
		const slidesObject = getSlidesObject(".slides__slide")

		//Setup base state
		let state = {
			isScrolling: false,
			currentElement: slides[0].dataset.id
		};

		const setupBasePage = () => {
			//Get active slide from url
			const activeSlide = getActiveSlide({
				query: ".slides__slide",
				elementsObject: slidesObject
			})

			//If no active slide redirect user to first slide
			if(!activeSlide){
				window.location.hash = slides[0].id;
			}else{
				//If active slide is not first slide then scroll active slide into view
				if(activeSlide !== state.currentElement){
					slidesObject[activeSlide].element.scrollIntoView();
				}
			}
		}

		const setupObserver = () => {
			//Function to trigger on intersection change
			const handleIntersection = (entries) => {
				entries.forEach(entry => {
					if(entry.isIntersecting){
						//If the smooth scroll is currently active then don't change the hash
						if(state.isScrolling) return

						//Else change the hash and the current element because the scroll was triggered by the user's mouse events
						const id = entry.target.dataset.id;
						state.currentElement = id;
						window.location.hash = id;
					}
				})
			}

			//Create intersection observer
			const slideObserver = new IntersectionObserver(handleIntersection, {
				rootMargin: "0px",
				threshold: 0.9
			});

			//Observe all slides
			slides.forEach(element => {
				slideObserver.observe(element)
			});
		}

		const handleHashChange = () => {
			//Get current active slide
            const activeSlide = getActiveSlide({
				query: ".slides__slide",
				elementsObject: slidesObject
			})

			//If invalid slide redirect to first slide
			if(!activeSlide){
				window.location.hash = slides[0].dataset.id;
				return
			}

            const activeSlideEl = slidesObject[activeSlide].element;

			//Get slide width and active slide position
			const slideWidth = window.innerWidth;
			const activeSlideOffset = activeSlideEl.offsetLeft;

			/*
				The percentage here is used as such
				If percentage is <= 0.1 then the hash change was triggered by the intersection observer
				and therefore the user already used a normal scroll event and the scroll snap will align the page correctly

				If percentage > 0.1 then the hash change was triggered by clicking on the slides in the navbar
				and therefore we should scroll to the correct slide using the smooth scroll algorithm

			*/
			const percentage = Math.abs(activeSlideOffset - slidesWrapper.scrollLeft)/slideWidth

			if(percentage > 0.1){
				//Update scrolling
				state.isScrolling = true;

				/*
					Distance in index between previous element and current elements helps us scale the duration based on slides to scroll
					If 1 slide then we'll scroll 1 DURATION_PER_SLIDE
					If 3 slides then we'll scroll 3 DURATION_PER_SLIDEs
				*/
				const previousElementIndex = slidesObject[state.currentElement].index;
				const currentElementIndex = slidesObject[activeSlide].index;

				const DURATION_PER_SLIDE = 1

				const duration = Math.abs(currentElementIndex - previousElementIndex) * DURATION_PER_SLIDE

				smoothScroll({
					element: slidesWrapper,
					position: {
						x: activeSlideEl.offsetLeft,
						y: 0
					},
					duration,
					callback: () => {
						state.isScrolling = false
						state.currentElement = activeSlide
					},
					id: "slides",
					easing: "easeOutQuad"
				})
			}
        }

        window.addEventListener("hashchange", handleHashChange)

		setupBasePage()
		setupObserver()
	</script>
</html>